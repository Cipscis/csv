{"version":3,"file":"docs-script.bundle.js","mappings":"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","sources":["webpack://@cipscis/csv/./src/stringify.ts","webpack://@cipscis/csv/./src/parse.ts","webpack://@cipscis/csv/./docs/assets/js/src/docs-script.ts"],"sourcesContent":["export interface StringifyOptions {\r\n\t/**\r\n\t * If set to true, swap rows and columns before saving.\r\n\t *\r\n\t * @default false;\r\n\t */\r\n\ttranspose?: boolean;\r\n\r\n\t/**\r\n\t * If set to true, prepend each cell starting with `'=' | '-' | '+' | '@'` with a tab character. This prevents spreadsheet software like Excel from trying to execute code.\r\n\t *\r\n\t * This option should be used when saving any data to a CSV that may include data from an untrusted source, such as user-generated data.\r\n\t *\r\n\t * @default false;\r\n\t */\r\n\tsanitise?: boolean;\r\n}\r\n\r\n/**\r\n * Converts a 2D Array into a CSV string.\r\n *\r\n * `stringify` converts most falsey values into empty cells. `undefined`, `''`, and `[]` are all treated this way. `null` and `false`, however, are converted into string representations when stringifying CSV data.\r\n *\r\n * If you need to maintain a value of `undefined`, `''`, or `[]` when stringifying your CSV data, convert it to a string first (e.g. `'undefined'`)\r\n *\r\n * @param {any[][]} data - A 2D Array to convert into a CSV string.\r\n * @param {StringifyOptions} [options] - An object containing stringify options.\r\n *\r\n * @return {string} CSV string\r\n */\r\nfunction stringify(data: any[][], options?: StringifyOptions): string {\r\n\toptions = options || {};\r\n\toptions.transpose = options.transpose || false;\r\n\toptions.sanitise = options.sanitise || false;\r\n\r\n\t// Enforce square data and apply CSV escaping, then convert to string\r\n\tconst rows = data;\r\n\tconst shapedRows = _shape(data, options);\r\n\tconst escapedRows = _escape(shapedRows, options);\r\n\tconst joinedRows = _join(escapedRows);\r\n\r\n\treturn joinedRows;\r\n}\r\n\r\n/**\r\n * Pad missing cells with empty strings and, if necessary, transpose the data\r\n *\r\n * @param {any[][]} data - A 2D Array to pad and potentially transpose.\r\n * @param {StringifyOptions} [options] - An object containing stringify options.\r\n *\r\n * @return {any[][]} Shaped CSV data\r\n */\r\nfunction _shape(data: any[][], options?: StringifyOptions): any[][] {\r\n\tconst transpose = options?.transpose ?? false;\r\n\r\n\tconst maxLength = data.reduce((maxLength, row) => Math.max(maxLength, row.length), 0);\r\n\r\n\t// Flip rows and columns if transposing data\r\n\tconst iMax = transpose ? maxLength : data.length;\r\n\tconst jMax = transpose ? data.length : maxLength;\r\n\r\n\tconst rows = [];\r\n\tfor (let i = 0; i < iMax; i++) {\r\n\t\tconst row = [];\r\n\t\tfor (let j = 0; j < jMax; j++) {\r\n\t\t\tconst iRow = transpose ? j : i;\r\n\t\t\tconst iCol = transpose ? i : j;\r\n\r\n\t\t\tlet cellValue = data[iRow][iCol];\r\n\r\n\t\t\tif (iCol >= data[iRow].length) {\r\n\t\t\t\tcellValue = '';\r\n\t\t\t}\r\n\r\n\t\t\trow.push(cellValue);\r\n\t\t}\r\n\t\trows.push(row);\r\n\t}\r\n\r\n\treturn rows;\r\n}\r\n\r\n/**\r\n * Make sure any cells containing \" or , or a newline are escaped appropriately\r\n *\r\n * @param {any[][]} rows - A 2D Array with values to escape\r\n * @param {StringifyOptions} [options] - An object containing stringify options.\r\n *\r\n * @return {string[][]} Escaped CSV data\r\n */\r\nfunction _escape(rows: any[][], options?: StringifyOptions): string[][] {\r\n\tfor (const row of rows) {\r\n\t\tfor (let j = 0; j < row.length; j++) {\r\n\t\t\trow[j] = _escapeCell(row[j], options);\r\n\t\t}\r\n\t}\r\n\r\n\treturn rows;\r\n}\r\n\r\n/**\r\n * Make sure any cells containing \" or , or a newline are escaped appropriately\r\n *\r\n * @param {any} cell - A single value to escape\r\n * @param {StringifyOptions} [options] - An object containing stringify options.\r\n *\r\n * @return {string} Escaped value\r\n */\r\nfunction _escapeCell(cell: any, options?: StringifyOptions): string {\r\n\tconst sanitise = options?.sanitise ?? false;\r\n\r\n\t// Convert to string\r\n\tlet cellString: string;\r\n\tif (typeof cell === 'undefined') {\r\n\t\t// Replace undefined with ''\r\n\t\tcellString = '';\r\n\t} else if (typeof cell !== 'string') {\r\n\t\t// Convert to string\r\n\t\tcellString = '' + cell;\r\n\t} else {\r\n\t\tcellString = cell;\r\n\t}\r\n\r\n\t// Sanitise\r\n\tif (sanitise) {\r\n\t\t// Prevent spreadsheet software like\r\n\t\t// Excel from trying to execute code\r\n\t\tif (cellString.match(/^[=\\-+@]/)) {\r\n\t\t\tcellString = '\\t' + cell;\r\n\t\t}\r\n\t}\r\n\r\n\t// Escape\r\n\tif (cellString.match(/,|\"|\\n|\\r/)) {\r\n\t\t// Turn any double quotes into escaped double quotes\r\n\t\tcellString = cellString.replace(/\"/g, '\"\"');\r\n\r\n\t\t// Wrap cell in double quotes\r\n\t\tcellString = '\"' + cellString + '\"';\r\n\t}\r\n\r\n\treturn cellString;\r\n}\r\n\r\n/**\r\n * Join escaped CSV data into a single string.\r\n *\r\n * @param  {string[][]} rows - A 2D Array containing escaped CSV data\r\n *\r\n * @return {string} A CSV string\r\n */\r\nfunction _join(rows: string[][]): string {\r\n\tconst rowStrings = [];\r\n\r\n\tfor (let i = 0; i < rows.length; i++) {\r\n\t\trowStrings.push(rows[i].join(','));\r\n\t}\r\n\r\n\tconst rowsString = rowStrings.join('\\n');\r\n\treturn rowsString;\r\n}\r\n\r\nexport { stringify };\r\n","/**\r\n * Converts a CSV string into a 2D Array.\r\n *\r\n * `parse` will throw a SyntaxError if the string it is passed is malformed in\r\n *   one of these ways:\r\n *\r\n * - Unclosed quote - closed quote not followed immediately by separator - Rows\r\n *   of unequal lengths\r\n *\r\n * All values are converted to strings. If you need to convert them further, for\r\n *   example changing the strings `'true'` and `'false'` to boolean values, you\r\n *   can do this in separate code after the fact.\r\n *\r\n * @template T=string\r\n *\r\n * @param {string} csvString - A CSV string to convert to a 2D Array.\r\n * @param {ParseOptions} [options] - An object containing parse options.\r\n *\r\n * @throws {SyntaxError} - The csvString must not be malformed.\r\n *\r\n * @return {T[][]} 2D Array\r\n */\r\nfunction parse(csvString: string): string[][];\r\nfunction parse<T>(csvString: string, mapper: (cell: string) => T): T[][]\r\nfunction parse<T>(csvString: string, mapper?: (cell: string) => T): T[][] | string[][] {\r\n\tconst stringRows = _tokenise(csvString);\r\n\r\n\t_validate(stringRows);\r\n\r\n\tif (typeof mapper !== 'undefined') {\r\n\t\tconst dataRows = stringRows.map((row) => row.map(mapper));\r\n\t\treturn dataRows;\r\n\t} else {\r\n\t\treturn stringRows;\r\n\t}\r\n}\r\n\r\n/**\r\n * Walk through each character and produce an array of cell values. Throws an error if the string is not formatted as expected for a CSV.\r\n *\r\n * @param {string} csvString - A string representation of a CSV.\r\n *\r\n * @throws {SyntaxError} - The csvString must not be malformed.\r\n */\r\nfunction _tokenise(csvString: string): string[][] {\r\n\t// Walk through each character and produce an array of tokens\r\n\r\n\tconst tokens = [];\r\n\r\n\t// Remove carriage returns\r\n\tcsvString = csvString.replace(/\\r/g, '');\r\n\r\n\tlet inQuote = false;\r\n\tlet wasQuote = false;\r\n\r\n\tlet tokenStart = 0;\r\n\tlet row = [];\r\n\tfor (let i = 0; i < csvString.length; i++) {\r\n\t\tconst char = csvString[i];\r\n\r\n\t\tconst comma = char === ',';\r\n\t\tconst quote = char === '\"';\r\n\t\tconst newline = char === '\\n';\r\n\t\tconst eof = i === csvString.length -1; // eof - End Of File\r\n\r\n\t\tif (inQuote) {\r\n\t\t\t// Characters may be delimited\r\n\t\t\tif (quote) {\r\n\t\t\t\t// Check if the next character is another double quote, i.e. if it is escaped\r\n\t\t\t\tconst nextChar = csvString[i+1];\r\n\r\n\t\t\t\tif (nextChar === '\"') {\r\n\t\t\t\t\t// This and the next character combined make an escaped double quote,\r\n\t\t\t\t\t// so the quote has not ended and we should skip over the next character\r\n\t\t\t\t\ti++;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// The quote has ended\r\n\t\t\t\t\tinQuote = false;\r\n\t\t\t\t\twasQuote = true;\r\n\r\n\t\t\t\t\tif (!eof) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else if (eof) {\r\n\t\t\t\tthrow new SyntaxError(`CSV parse: Reached end of file before ending quote. At index ${i}`);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!inQuote && (comma || newline || eof)) {\r\n\t\t\t// These are the characters that denote the end of a token\r\n\t\t\tlet token = csvString.substring(tokenStart, i+1);\r\n\r\n\t\t\tif (comma || newline) {\r\n\t\t\t\t// Don't keep the separator\r\n\t\t\t\ttoken = token.substring(0, token.length - 1);\r\n\t\t\t}\r\n\r\n\t\t\tif (wasQuote) {\r\n\t\t\t\twasQuote = false;\r\n\r\n\t\t\t\t// Remove start and end quotes\r\n\t\t\t\ttoken = token.substring(1, token.length - 1);\r\n\r\n\t\t\t\t// Replace escaped quotes\r\n\t\t\t\ttoken = token.replace(/\"\"/g, '\"');\r\n\t\t\t}\r\n\t\t\trow.push(token);\r\n\r\n\t\t\tif (comma && eof) {\r\n\t\t\t\t// It's the end of the last token, and the last cell is empty\r\n\t\t\t\trow.push('');\r\n\t\t\t}\r\n\r\n\t\t\tif (newline || eof) {\r\n\t\t\t\ttokens.push(row);\r\n\t\t\t\tif (newline) {\r\n\t\t\t\t\trow = [];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\ttokenStart = i+1;\r\n\t\t} else if (wasQuote) {\r\n\t\t\tthrow new SyntaxError(`CSV parse: A value must be complete immediately after closing a quote. At index ${i}`);\r\n\t\t} else if (quote) {\r\n\t\t\tinQuote = true;\r\n\t\t}\r\n\t}\r\n\r\n\treturn tokens;\r\n}\r\n\r\n/**\r\n * Checks that an array of CSV values is rectangular, i.e. that each row has the same length.\r\n *\r\n * Throws a SyntaxError if validation fails.\r\n *\r\n * @param {string[][]} rows - A 2D array of CSV values.\r\n *\r\n * @throws {SyntaxError} - The rows 2D Array must not be malformed.\r\n */\r\nfunction _validate(rows: string[][]): void {\r\n\t// Each row of a CSV should have the same length;\r\n\r\n\tif (rows && rows.length > 1) {\r\n\t\tlet rowLength = rows[0].length;\r\n\t\tfor (let i = 1; i < rows.length; i++) {\r\n\t\t\tlet row = rows[i];\r\n\r\n\t\t\tif (row.length !== rowLength) {\r\n\t\t\t\tthrow new SyntaxError(`CSV parse: Row ${i} does not have the same length as the first row (${rowLength})`);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport { parse };\r\n","import { stringify, parse } from '@cipscis/csv';\n\nconst stringifyInput = [\n\t['Numbers', 0, 1, 2, 3],\n\t['Test values', 'test', {test: true}],\n\t['Falsey values', false, '', [], null],\n\t['Values to sanitise', '=GET(malicious_code)', '-FETCH(url)', '+DO(nefarious_thing)', '@POST(data)'],\n];\n\nconst parseInput = `Numbers,0,1,2,3\nTest values,test,{test: true},,\nFalsey values,false,'',[],null\nValues to sanitise,=GET(malicious_code),-FETCH(url),+DO(nefarious_thing),@POST(data)`;\n\ndocument.querySelectorAll('.js-stringify__button').forEach(($el) => $el.addEventListener('click', () => {\n\tconst $input = document.querySelector('.js-stringify__input');\n\tconst $output = document.querySelector('.js-stringify__output');\n\n\tconst $transpose = document.querySelector('.js-stringify__transpose');\n\tconst $sanitise = document.querySelector('.js-stringify__sanitise');\n\n\tconst transpose = $transpose instanceof HTMLInputElement ? $transpose.checked : false;\n\tconst sanitise = $sanitise instanceof HTMLInputElement ? $sanitise.checked : false;\n\n\tconst options = {\n\t\ttranspose,\n\t\tsanitise,\n\t};\n\n\tconst str = stringify(stringifyInput, options);\n\n\tif ($input) {\n\t\t$input.innerHTML = JSON.stringify(stringifyInput, null, '\\t');\n\t}\n\tif ($output) {\n\t\t$output.innerHTML = str;\n\t}\n}));\n\ndocument.querySelectorAll('.js-parse__button').forEach(($el) => $el.addEventListener('click', () => {\n\tconst $input = document.querySelector('.js-parse__input');\n\tconst $output = document.querySelector('.js-parse__output');\n\n\tconst $mapIntegers = document.querySelector('.js-parse__map-integers');\n\tconst mapIntegersChecked = $mapIntegers instanceof HTMLInputElement ? $mapIntegers.checked : false;\n\n\tconst data = (() => {\n\t\tlet data;\n\n\t\tif (mapIntegersChecked) {\n\t\t\tconst mapper = (value: string) => {\n\t\t\t\tif (+value === parseInt(value, 10)) {\n\t\t\t\t\treturn +value;\n\t\t\t\t} else {\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tdata = parse(parseInput, mapper);\n\t\t} else {\n\t\t\tdata = parse(parseInput);\n\t\t}\n\n\t\treturn data;\n\t})();\n\n\tif ($input) {\n\t\t$input.innerHTML = parseInput;\n\t}\n\tif ($output) {\n\t\t$output.innerHTML = JSON.stringify(data, null, '\\t');\n\t}\n}));\n"],"names":["_escapeCell","cell","options","cellString","sanitise","match","replace","parse","csvString","mapper","stringRows","tokens","inQuote","wasQuote","tokenStart","row","i","length","char","comma","quote","newline","eof","SyntaxError","token","substring","push","_tokenise","rows","rowLength","_validate","map","stringifyInput","test","parseInput","document","querySelectorAll","forEach","$el","addEventListener","$input","querySelector","$output","$transpose","$sanitise","transpose","HTMLInputElement","checked","str","data","rowStrings","join","_join","j","_escape","maxLength","reduce","Math","max","iMax","jMax","iRow","iCol","cellValue","_shape","innerHTML","JSON","stringify","$mapIntegers","mapIntegersChecked","value","parseInt"],"sourceRoot":""}