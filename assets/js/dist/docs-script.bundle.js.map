{"version":3,"file":"docs-script.bundle.js","mappings":"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","sources":["webpack://@cipscis/csv/./src/csv.ts","webpack://@cipscis/csv/./docs/assets/js/src/docs-script.ts"],"sourcesContent":["export interface StringifyOptions {\n\t/**\n\t * If set to true, swap rows and columns before saving.\n\t *\n\t * @default false;\n\t */\n\ttranspose?: boolean;\n\n\t/**\n\t * If set to true, prepend each cell starting with `'=' | '-' | '+' | '@'` with a tab character. This prevents spreadsheet software like Excel from trying to execute code.\n\t *\n\t * This option should be used when saving any data to a CSV that may include data from an untrusted source, such as user-generated data.\n\t *\n\t * @default false;\n\t */\n\tsanitise?: boolean;\n}\n\n/**\n * Converts a 2D Array into a CSV string.\n *\n * `stringify` converts most falsey values into empty cells. `undefined`, `''`, and `[]` are all treated this way. `null` and `false`, however, are converted into string representations when stringifying CSV data.\n *\n * If you need to maintain a value of `undefined`, `''`, or `[]` when stringifying your CSV data, convert it to a string first (e.g. `'undefined'`)\n *\n * @param {any[][]} data - A 2D Array to convert into a CSV string.\n * @param {StringifyOptions} [options] - An object containing stringify options.\n *\n * @return {string} CSV string\n */\nfunction stringify(data: any[][], options?: StringifyOptions): string {\n\toptions = options || {};\n\toptions.transpose = options.transpose || false;\n\toptions.sanitise = options.sanitise || false;\n\n\t// Enforce square data and apply CSV escaping, then convert to string\n\tconst rows = data;\n\tconst shapedRows = _shape(data, options);\n\tconst escapedRows = _escape(shapedRows, options);\n\tconst joinedRows = _join(escapedRows);\n\n\treturn joinedRows;\n}\n\n/**\n * Pad missing cells with empty strings and, if necessary, transpose the data\n *\n * @param {any[][]} data - A 2D Array to pad and potentially transpose.\n * @param {StringifyOptions} [options] - An object containing stringify options.\n *\n * @return {any[][]} Shaped CSV data\n */\nfunction _shape(data: any[][], options?: StringifyOptions): any[][] {\n\tconst transpose = options?.transpose ?? false;\n\n\tconst maxLength = data.reduce((maxLength, row) => Math.max(maxLength, row.length), 0);\n\n\t// Flip rows and columns if transposing data\n\tconst iMax = transpose ? maxLength : data.length;\n\tconst jMax = transpose ? data.length : maxLength;\n\n\tconst rows = [];\n\tfor (let i = 0; i < iMax; i++) {\n\t\tconst row = [];\n\t\tfor (let j = 0; j < jMax; j++) {\n\t\t\tconst iRow = transpose ? j : i;\n\t\t\tconst iCol = transpose ? i : j;\n\n\t\t\tlet cellValue = data[iRow][iCol];\n\n\t\t\tif (iCol >= data[iRow].length) {\n\t\t\t\tcellValue = '';\n\t\t\t}\n\n\t\t\trow.push(cellValue);\n\t\t}\n\t\trows.push(row);\n\t}\n\n\treturn rows;\n}\n\n/**\n * Make sure any cells containing \" or , or a newline are escaped appropriately\n *\n * @param {any[][]} rows - A 2D Array with values to escape\n * @param {StringifyOptions} [options] - An object containing stringify options.\n *\n * @return {string[][]} Escaped CSV data\n */\nfunction _escape(rows: any[][], options?: StringifyOptions): string[][] {\n\tfor (const row of rows) {\n\t\tfor (let j = 0; j < row.length; j++) {\n\t\t\trow[j] = _escapeCell(row[j], options);\n\t\t}\n\t}\n\n\treturn rows;\n}\n\n/**\n * Make sure any cells containing \" or , or a newline are escaped appropriately\n *\n * @param {any} cell - A single value to escape\n * @param {StringifyOptions} [options] - An object containing stringify options.\n *\n * @return {string} Escaped value\n */\nfunction _escapeCell(cell: any, options?: StringifyOptions): string {\n\tconst sanitise = options?.sanitise ?? false;\n\n\t// Convert to string\n\tlet cellString: string;\n\tif (typeof cell === 'undefined') {\n\t\t// Replace undefined with ''\n\t\tcellString = '';\n\t} else if (typeof cell !== 'string') {\n\t\t// Convert to string\n\t\tcellString = '' + cell;\n\t} else {\n\t\tcellString = cell;\n\t}\n\n\t// Sanitise\n\tif (sanitise) {\n\t\t// Prevent spreadsheet software like\n\t\t// Excel from trying to execute code\n\t\tif (cellString.match(/^[=\\-+@]/)) {\n\t\t\tcellString = '\\t' + cell;\n\t\t}\n\t}\n\n\t// Escape\n\tif (cellString.match(/,|\"|\\n/)) {\n\t\t// Turn any double quotes into escaped double quotes\n\t\tcellString = cellString.replace(/\"/g, '\"\"');\n\n\t\t// Wrap cell in double quotes\n\t\tcellString = '\"' + cellString + '\"';\n\t}\n\n\treturn cellString;\n}\n\n/**\n * Join escaped CSV data into a single string.\n *\n * @param  {string[][]} rows - A 2D Array containing escaped CSV data\n *\n * @return {string} A CSV string\n */\nfunction _join(rows: string[][]): string {\n\tconst rowStrings = [];\n\n\tfor (let i = 0; i < rows.length; i++) {\n\t\trowStrings.push(rows[i].join(','));\n\t}\n\n\tconst rowsString = rowStrings.join('\\n');\n\treturn rowsString;\n}\n\n\n/**\n * Converts a CSV string into a 2D Array.\n *\n * `parse` will throw a SyntaxError if the string it is passed is malformed in\n *   one of these ways:\n *\n * - Unclosed quote - closed quote not followed immediately by separator - Rows\n *   of unequal lengths\n *\n * All values are converted to strings. If you need to convert them further, for\n *   example changing the strings `'true'` and `'false'` to boolean values, you\n *   can do this in separate code after the fact.\n *\n * @template T=string\n *\n * @param {string} csvString - A CSV string to convert to a 2D Array.\n * @param {ParseOptions} [options] - An object containing parse options.\n *\n * @throws {SyntaxError} - The csvString must not be malformed.\n *\n * @return {T[][]} 2D Array\n */\nfunction parse(csvString: string): string[][];\nfunction parse<T>(csvString: string, mapper: (cell: string) => T): T[][]\nfunction parse<T>(csvString: string, mapper?: (cell: string) => T): T[][] | string[][] {\n\tconst stringRows = _tokenise(csvString);\n\n\t_validate(stringRows);\n\n\tif (typeof mapper !== 'undefined') {\n\t\tconst dataRows = stringRows.map((row) => row.map(mapper));\n\t\treturn dataRows;\n\t} else {\n\t\treturn stringRows;\n\t}\n}\n\n/**\n * Walk through each character and produce an array of cell values. Throws an error if the string is not formatted as expected for a CSV.\n *\n * @param {string} csvString - A string representation of a CSV.\n *\n * @throws {SyntaxError} - The csvString must not be malformed.\n */\nfunction _tokenise(csvString: string): string[][] {\n\t// Walk through each character and produce an array of tokens\n\n\tconst tokens = [];\n\n\t// Remove carriage returns\n\tcsvString = csvString.replace(/\\r/g, '');\n\n\tlet inQuote = false;\n\tlet wasQuote = false;\n\n\tlet tokenStart = 0;\n\tlet row = [];\n\tfor (let i = 0; i < csvString.length; i++) {\n\t\tconst char = csvString[i];\n\n\t\tconst comma = char === ',';\n\t\tconst quote = char === '\"';\n\t\tconst newline = char === '\\n';\n\t\tconst eof = i === csvString.length -1; // eof - End Of File\n\n\t\tif (inQuote) {\n\t\t\t// Characters may be delimited\n\t\t\tif (quote) {\n\t\t\t\t// Check if the next character is another double quote, i.e. if it is escaped\n\t\t\t\tconst nextChar = csvString[i+1];\n\n\t\t\t\tif (nextChar === '\"') {\n\t\t\t\t\t// This and the next character combined make an escaped double quote,\n\t\t\t\t\t// so the quote has not ended and we should skip over the next character\n\t\t\t\t\ti++;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\t// The quote has ended\n\t\t\t\t\tinQuote = false;\n\t\t\t\t\twasQuote = true;\n\n\t\t\t\t\tif (!eof) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (eof) {\n\t\t\t\tthrow new SyntaxError(`CSV parse: Reached end of file before ending quote. At index ${i}`);\n\t\t\t}\n\t\t}\n\n\t\tif (!inQuote && (comma || newline || eof)) {\n\t\t\t// These are the characters that denote the end of a token\n\t\t\tlet token = csvString.substring(tokenStart, i+1);\n\n\t\t\tif (comma || newline) {\n\t\t\t\t// Don't keep the separator\n\t\t\t\ttoken = token.substring(0, token.length - 1);\n\t\t\t}\n\n\t\t\tif (wasQuote) {\n\t\t\t\twasQuote = false;\n\n\t\t\t\t// Remove start and end quotes\n\t\t\t\ttoken = token.substring(1, token.length - 1);\n\n\t\t\t\t// Replace escaped quotes\n\t\t\t\ttoken = token.replace(/\"\"/g, '\"');\n\t\t\t}\n\t\t\trow.push(token);\n\n\t\t\tif (comma && eof) {\n\t\t\t\t// It's the end of the last token, and the last cell is empty\n\t\t\t\trow.push('');\n\t\t\t}\n\n\t\t\tif (newline || eof) {\n\t\t\t\ttokens.push(row);\n\t\t\t\tif (newline) {\n\t\t\t\t\trow = [];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttokenStart = i+1;\n\t\t} else if (wasQuote) {\n\t\t\tthrow new SyntaxError(`CSV parse: A value must be complete immediately after closing a quote. At index ${i}`);\n\t\t} else if (quote) {\n\t\t\tinQuote = true;\n\t\t}\n\t}\n\n\treturn tokens;\n}\n\n/**\n * Checks that an array of CSV values is rectangular, i.e. that each row has the same length.\n *\n * Throws a SyntaxError if validation fails.\n *\n * @param {string[][]} rows - A 2D array of CSV values.\n *\n * @throws {SyntaxError} - The rows 2D Array must not be malformed.\n */\nfunction _validate(rows: string[][]): void {\n\t// Each row of a CSV should have the same length;\n\n\tif (rows && rows.length > 1) {\n\t\tlet rowLength = rows[0].length;\n\t\tfor (let i = 1; i < rows.length; i++) {\n\t\t\tlet row = rows[i];\n\n\t\t\tif (row.length !== rowLength) {\n\t\t\t\tthrow new SyntaxError(`CSV parse: Row ${i} does not have the same length as the first row (${rowLength})`);\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport {\n\tstringify,\n\tparse,\n};\n","import { stringify, parse } from '@cipscis/csv';\n\nconst stringifyInput = [\n\t['Numbers', 0, 1, 2, 3],\n\t['Test values', 'test', {test: true}],\n\t['Falsey values', false, '', [], null],\n\t['Values to sanitise', '=GET(malicious_code)', '-FETCH(url)', '+DO(nefarious_thing)', '@POST(data)'],\n];\n\nconst parseInput = `Numbers,0,1,2,3\nTest values,test,{test: true},,\nFalsey values,false,'',[],null\nValues to sanitise,=GET(malicious_code),-FETCH(url),+DO(nefarious_thing),@POST(data)`;\n\ndocument.querySelectorAll('.js-stringify__button').forEach(($el) => $el.addEventListener('click', () => {\n\tconst $input = document.querySelector('.js-stringify__input');\n\tconst $output = document.querySelector('.js-stringify__output');\n\n\tconst $transpose = document.querySelector('.js-stringify__transpose');\n\tconst $sanitise = document.querySelector('.js-stringify__sanitise');\n\n\tconst transpose = $transpose instanceof HTMLInputElement ? $transpose.checked : false;\n\tconst sanitise = $sanitise instanceof HTMLInputElement ? $sanitise.checked : false;\n\n\tconst options = {\n\t\ttranspose,\n\t\tsanitise,\n\t};\n\n\tconst str = stringify(stringifyInput, options);\n\n\tif ($input) {\n\t\t$input.innerHTML = JSON.stringify(stringifyInput, null, '\\t');\n\t}\n\tif ($output) {\n\t\t$output.innerHTML = str;\n\t}\n}));\n\ndocument.querySelectorAll('.js-parse__button').forEach(($el) => $el.addEventListener('click', () => {\n\tconst $input = document.querySelector('.js-parse__input');\n\tconst $output = document.querySelector('.js-parse__output');\n\n\tconst $mapIntegers = document.querySelector('.js-parse__map-integers');\n\tconst mapIntegersChecked = $mapIntegers instanceof HTMLInputElement ? $mapIntegers.checked : false;\n\n\tconst data = (() => {\n\t\tlet data;\n\n\t\tif (mapIntegersChecked) {\n\t\t\tconst mapper = (value: string) => {\n\t\t\t\tif (+value === parseInt(value, 10)) {\n\t\t\t\t\treturn +value;\n\t\t\t\t} else {\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tdata = parse(parseInput, mapper);\n\t\t} else {\n\t\t\tdata = parse(parseInput);\n\t\t}\n\n\t\treturn data;\n\t})();\n\n\tif ($input) {\n\t\t$input.innerHTML = parseInput;\n\t}\n\tif ($output) {\n\t\t$output.innerHTML = JSON.stringify(data, null, '\\t');\n\t}\n}));\n"],"names":["_escapeCell","cell","options","cellString","sanitise","match","replace","parse","csvString","mapper","stringRows","tokens","inQuote","wasQuote","tokenStart","row","i","length","char","comma","quote","newline","eof","SyntaxError","token","substring","push","_tokenise","rows","rowLength","_validate","map","stringifyInput","test","parseInput","document","querySelectorAll","forEach","$el","addEventListener","$input","querySelector","$output","$transpose","$sanitise","transpose","HTMLInputElement","checked","str","data","rowStrings","join","_join","j","_escape","maxLength","reduce","Math","max","iMax","jMax","iRow","iCol","cellValue","_shape","innerHTML","JSON","stringify","$mapIntegers","mapIntegersChecked","value","parseInt"],"sourceRoot":""}